import "package:juicer/metadata.dart";
import "something.juicer.dart";
// ignore_for_file: invalid_use_of_protected_member
// ignore_for_file: unnecessary_cast
import 'package:juicer/juicer_util.dart';


enum NatoAlphabet {
  alfa,
  bravo,
  charlie,
  delta,
  echo,
  foxtrot,
  golf,
  hotel,
  india,
  juliett,
  kilo,
  lima,
  mike,
  november,
  oscar,
  papa,
  quebec,
  romeo,
  sierra,
  tango,
  uniform,
  victor,
  whiskey,
  xray,
  yankee,
  zulu,
}

/// This is a different class. Different to `Something`.
@juiced
class Different {
  Different(this.fooString);

  Different.json();

  NatoAlphabet letter;
  List<NatoAlphabet> string;
  Map<String, NatoAlphabet> encoding;

  String fooString;
  Something something;

  Map<String, /*List<int>*/ dynamic> deep; // deep types are not supported yet

  Map<String, Map> notSoDeep;

  Map<String, Different> otherNamedDiffs;

  /// It's a random number generated by a fair die roll at the time of writing.
  /// Yeah, no, it's not.
  /// But it might as well be.
  int get readOnly => 7;

  set writeOnly(String value) => print(value);
  @override
  bool operator ==(Object other) => juicerEquals(other);
  @override
  int get hashCode => juicerHashCode();
}
// package:juicer_gen_test/sample_classes/different.dart Different
extension package_juicer_gen_test_sample_classes_different_dart__DifferentJuicer on Different {
static Different createJuicableInstance() => Different.json();
  static const package_juicer_gen_test_sample_classes_different_dart__NatoAlphabetJuicer = {
    "alfa": NatoAlphabet.alfa,
    "bravo": NatoAlphabet.bravo,
    "charlie": NatoAlphabet.charlie,
    "delta": NatoAlphabet.delta,
    "echo": NatoAlphabet.echo,
    "foxtrot": NatoAlphabet.foxtrot,
    "golf": NatoAlphabet.golf,
    "hotel": NatoAlphabet.hotel,
    "india": NatoAlphabet.india,
    "juliett": NatoAlphabet.juliett,
    "kilo": NatoAlphabet.kilo,
    "lima": NatoAlphabet.lima,
    "mike": NatoAlphabet.mike,
    "november": NatoAlphabet.november,
    "oscar": NatoAlphabet.oscar,
    "papa": NatoAlphabet.papa,
    "quebec": NatoAlphabet.quebec,
    "romeo": NatoAlphabet.romeo,
    "sierra": NatoAlphabet.sierra,
    "tango": NatoAlphabet.tango,
    "uniform": NatoAlphabet.uniform,
    "victor": NatoAlphabet.victor,
    "whiskey": NatoAlphabet.whiskey,
    "xray": NatoAlphabet.xray,
    "yankee": NatoAlphabet.yankee,
    "zulu": NatoAlphabet.zulu,
  };
  static const package_juicer_gen_test_sample_classes_different_dart__NatoAlphabetJuicerReverse = {
    NatoAlphabet.alfa: "alfa",
    NatoAlphabet.bravo: "bravo",
    NatoAlphabet.charlie: "charlie",
    NatoAlphabet.delta: "delta",
    NatoAlphabet.echo: "echo",
    NatoAlphabet.foxtrot: "foxtrot",
    NatoAlphabet.golf: "golf",
    NatoAlphabet.hotel: "hotel",
    NatoAlphabet.india: "india",
    NatoAlphabet.juliett: "juliett",
    NatoAlphabet.kilo: "kilo",
    NatoAlphabet.lima: "lima",
    NatoAlphabet.mike: "mike",
    NatoAlphabet.november: "november",
    NatoAlphabet.oscar: "oscar",
    NatoAlphabet.papa: "papa",
    NatoAlphabet.quebec: "quebec",
    NatoAlphabet.romeo: "romeo",
    NatoAlphabet.sierra: "sierra",
    NatoAlphabet.tango: "tango",
    NatoAlphabet.uniform: "uniform",
    NatoAlphabet.victor: "victor",
    NatoAlphabet.whiskey: "whiskey",
    NatoAlphabet.xray: "xray",
    NatoAlphabet.yankee: "yankee",
    NatoAlphabet.zulu: "zulu",
  };
Map<String, dynamic> toMap() => removeNullValues({
"letter": package_juicer_gen_test_sample_classes_different_dart__NatoAlphabetJuicerReverse[this.letter],
"string": this.string?.map((e) => package_juicer_gen_test_sample_classes_different_dart__NatoAlphabetJuicerReverse[e])?.toList(),
"encoding": this.encoding == null ? null : Map.fromIterable(this.encoding.keys, value: (k) => package_juicer_gen_test_sample_classes_different_dart__NatoAlphabetJuicerReverse[this.encoding[k]]),
"fooString": this.fooString,
"something": this.something?.toMap(),
"deep": this.deep == null ? null : Map.fromIterable(this.deep.keys, value: (k) => this.deep[k]),
"notSoDeep": this.notSoDeep == null ? null : Map.fromIterable(this.notSoDeep.keys, value: (k) => this.notSoDeep[k]),
"otherNamedDiffs": this.otherNamedDiffs == null ? null : Map.fromIterable(this.otherNamedDiffs.keys, value: (k) => this.otherNamedDiffs[k]?.toMap()),
"readOnly": this.readOnly,
// writeOnly is ignored
});
Different populateFromMap(Map map) {
if (map.containsKey("letter")) this.letter = package_juicer_gen_test_sample_classes_different_dart__NatoAlphabetJuicer[map["letter"]];
if (map.containsKey("string")) this.string =  map["string"]?.map<NatoAlphabet>((val) => package_juicer_gen_test_sample_classes_different_dart__NatoAlphabetJuicer[val])?.toList();
if (map.containsKey("encoding")) this.encoding =  map["encoding"] == null ? null : nullSafeMapJsonMapValues(map["encoding"], (val) => package_juicer_gen_test_sample_classes_different_dart__NatoAlphabetJuicer[val]);
if (map.containsKey("fooString")) this.fooString =  map["fooString"];
if (map.containsKey("something")) this.something =  map["something"] == null ? null : package_juicer_gen_test_sample_classes_something_dart__SomethingJuicer.createJuicableInstance().populateFromMap(map["something"]);
if (map.containsKey("deep")) this.deep =  map["deep"] == null ? null : Map<String,dynamic>.from(map["deep"]);
if (map.containsKey("notSoDeep")) this.notSoDeep =  map["notSoDeep"] == null ? null : Map<String,Map>.from(map["notSoDeep"]);
if (map.containsKey("otherNamedDiffs")) this.otherNamedDiffs =  map["otherNamedDiffs"] == null ? null : nullSafeMapJsonMapValues(map["otherNamedDiffs"], (val) => package_juicer_gen_test_sample_classes_different_dart__DifferentJuicer.createJuicableInstance().populateFromMap(val));
// readOnly is ignored
if (map.containsKey("writeOnly")) this.writeOnly =  map["writeOnly"];
return this; }
Different copyWith({
NatoAlphabet letter, 
List<NatoAlphabet> string, 
Map<String,NatoAlphabet> encoding, 
String fooString, 
Something something, 
Map<String,dynamic> deep, 
Map<String,Map> notSoDeep, 
Map<String,Different> otherNamedDiffs, 
}) => 
Different.json()..letter = letter ?? (this.letter)
..string = string ?? (this.string?.map<NatoAlphabet>((val) => package_juicer_gen_test_sample_classes_different_dart__NatoAlphabetJuicer[val])?.toList()
)
..encoding = encoding ?? (this.encoding == null ? null : nullSafeMapJsonMapValues(this.encoding, (val) => package_juicer_gen_test_sample_classes_different_dart__NatoAlphabetJuicer[val])
)
..fooString = fooString ?? (this.fooString)
..something = something ?? (this.something?.copyWith()
)
..deep = deep ?? (this.deep == null ? null : Map<String,dynamic>.from(this.deep)
)
..notSoDeep = notSoDeep ?? (this.notSoDeep == null ? null : Map<String,Map>.from(this.notSoDeep)
)
..otherNamedDiffs = otherNamedDiffs ?? (this.otherNamedDiffs == null ? null : nullSafeMapJsonMapValues(this.otherNamedDiffs, (val) => package_juicer_gen_test_sample_classes_different_dart__DifferentJuicer.createJuicableInstance().copyWith())
)
;bool juicerEquals(Object other) => identical(this, other) || (other is Different &&
true &&
customIterableEquals(this.string, other.string, (a, b) => true) &&
customMapEquals(this.encoding, other.encoding, (a, b) => true) &&
this.fooString == other.fooString &&
(identical(this.something, other.something) || (this.something?.juicerEquals(other.something) ?? false)) &&
customMapEquals(this.deep, other.deep, (a, b) => a == b) &&
customMapEquals(this.notSoDeep, other.notSoDeep, (a, b) => customMapEquals(a, b, (a, b) => a == b)) &&
customMapEquals(this.otherNamedDiffs, other.otherNamedDiffs, (a, b) => (identical(a, b) || (a?.juicerEquals(b) ?? false))) &&
this.readOnly == other.readOnly);
int juicerHashCode() => hashIterable([0,
hashIterable(string?.map((e) => 0)),
(encoding?.entries?.fold<int>(0, (prev, e) => prev ^ e.key.hashCode ^ e.value.hashCode) ?? 0),
fooString.hashCode,
(something?.juicerHashCode() ?? 0),
(deep?.entries?.fold<int>(0, (prev, e) => prev ^ e.key.hashCode ^ e.value.hashCode) ?? 0),
(notSoDeep?.entries?.fold<int>(0, (prev, e) => prev ^ e.key.hashCode ^ e.value.hashCode) ?? 0),
(otherNamedDiffs?.entries?.fold<int>(0, (prev, e) => prev ^ e.key.hashCode ^ e.value.hashCode) ?? 0),
readOnly.hashCode,
]);
}
